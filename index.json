[{"content":"MinIO Java SDK适用于与Amazon S3兼容的云存储\n参考于： minio中文网 代码来自于minio-java.min.io\n使用给定的HttpUrl对象、access key、secret key创建一个Minio client对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class MinioClietConfig{ @Bean public MinioClient minioClient(){ //从配置中心里取url、access key、secret key MinioClient minioClient = MinioClient.builder() .endpoint(\u0026#34;https://play.min.io\u0026#34;) .credentials(\u0026#34;Q3AM3UQ867SPQQA43P2F\u0026#34;, \u0026#34;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\u0026#34;) .build(); return minioClient } } 判断容器里面是否有对应的桶存在 1 2 3 4 5 6 7 boolean found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(\u0026#34;my-bucketname\u0026#34;).build()); if (found) { System.out.println(\u0026#34;my-bucketname exists\u0026#34;); } else { System.out.println(\u0026#34;my-bucketname does not exist\u0026#34;); } readFile的代码 1 2 3 4 5 6 7 8 9 10 11 12 try (InputStream stream = minioClient.getObject( GetObjectArgs.builder() .bucket(\u0026#34;my-bucketname\u0026#34;) .object(\u0026#34;my-objectname\u0026#34;) .offset(offset) .length(len) .ssec(ssec) .build() ) { // Read data from stream } getFileUrl 1 2 3 4 5 6 7 8 9 10 11 // Get presigned URL string to download \u0026#39;my-objectname\u0026#39; in \u0026#39;my-bucketname\u0026#39; and its life time // is 2 hours. String url = minioClient.getPresignedObjectUrl( GetPresignedObjectUrlArgs.builder() .method(Method.GET) .bucket(\u0026#34;my-bucketname\u0026#34;) .object(\u0026#34;my-objectname\u0026#34;) .expiry(2, TimeUnit.HOURS) .build()); System.out.println(url); removeFile 1 2 3 // Remove object. minioClient.removeObject( RemoveObjectArgs.builder().bucket(\u0026#34;my-bucketname\u0026#34;).object(\u0026#34;my-objectname\u0026#34;).build()); fileUploader 1 2 3 4 5 6 7 8 Example: // Upload known sized input stream. minioClient.putObject( PutObjectArgs.builder().bucket(\u0026#34;my-bucketname\u0026#34;).object(\u0026#34;my-objectname\u0026#34;).stream( inputStream, size, -1) // 类型可省略 .contentType(\u0026#34;video/mp4\u0026#34;) .build()); ","permalink":"https://www.ryujinx.top/posts/tech/minio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003eMinIO Java SDK适用于与Amazon S3兼容的云存储\u003c/p\u003e","title":""},{"content":"python基础 数据类型和变量 Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。\n对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。\n注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。\nPython的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。\n字符串和编码 Python 3的字符串使用Unicode，直接支持多语言。\n当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：\n1 2 \u0026gt;\u0026gt;\u0026gt; \u0026#39;中文\u0026#39;.encode(\u0026#39;gb2312\u0026#39;) b\u0026#39;\\xd6\\xd0\\xce\\xc4\u0026#39; 但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。\n格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。\n使用list和tuple list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。\n条件判断 条件判断可以让计算机自己做选择，Python的if\u0026hellip;elif\u0026hellip;else很灵活。\n条件判断从上向下匹配，当满足条件时执行对应的块内语句，后续的elif和else都不再执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # 注意: # input()返回的是字符串 # 必须通过int()将字符串转换为整数 # 才能用于数值比较: age = int(input(\u0026#39;Input your age: \u0026#39;)) if age \u0026gt;= 18: print(\u0026#39;adult\u0026#39;) elif age \u0026gt;= 6: print(\u0026#39;teenager\u0026#39;) else: print(\u0026#39;kid\u0026#39;) 循环 循环是让计算机做重复任务的有效的方法。\nbreak语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。\n要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，许多情况下都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。\n有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。\n使用dict和set 使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。\n函数 调用函数 调用Python的函数，需要根据函数定义，传入正确的参数。如果函数调用出错，一定要学会看错误信息，所以英文很重要！\n定义函数 定义函数时，需要确定函数名和参数个数；\n如果有必要，可以先对参数的数据类型做检查；\n函数体内部可以用return随时返回函数结果；\n函数执行完毕也没有return语句时，自动return None。\n函数可以同时返回多个值，但其实就是一个tuple。\n函数的参数 Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。\n默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！\n要注意定义可变参数和关键字参数的语法：\n*args是可变参数，args接收的是一个tuple；\n**kw是关键字参数，kw接收的是一个dict。\n以及调用函数时如何传入可变参数和关键字参数的语法：\n可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；\n关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。\n使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。\n命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。\n定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。\n递归函数 使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。\n针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。\nPython标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。\n高级特性 切片 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026#39;ABCDEFG\u0026#39;[:3] \u0026#39;ABC\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;ABCDEFG\u0026#39;[::2] \u0026#39;ACEG\u0026#39; 迭代 任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。\n列表生成式 1 2 3 4 5 6 7 8 9 例子 \u0026gt;\u0026gt;\u0026gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： \u0026gt;\u0026gt;\u0026gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： \u0026gt;\u0026gt;\u0026gt; [m + n for m in \u0026#39;ABC\u0026#39; for n in \u0026#39;XYZ\u0026#39;] [\u0026#39;AX\u0026#39;, \u0026#39;AY\u0026#39;, \u0026#39;AZ\u0026#39;, \u0026#39;BX\u0026#39;, \u0026#39;BY\u0026#39;, \u0026#39;BZ\u0026#39;, \u0026#39;CX\u0026#39;, \u0026#39;CY\u0026#39;, \u0026#39;CZ\u0026#39;] 运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。\n生成器 generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。\n要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。\n请注意区分普通函数和generator函数，普通函数调用直接返回结果：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; r = abs(6) \u0026gt;\u0026gt;\u0026gt; r 6 generator函数的调用实际返回一个generator对象：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; g = fib(6) \u0026gt;\u0026gt;\u0026gt; g \u0026lt;generator object fib at 0x1022ef948\u0026gt; [源码]：https://github.com/michaelliao/learn-python3/blob/master/samples/advance/do_generator.py\n迭代器 凡是可作用于for循环的对象都是Iterable类型；\n凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；\n集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。\nPython的for循环本质上就是通过不断调用next()函数实现的，例如：\n1 2 for x in [1, 2, 3, 4, 5]: pass 实际上完全等价于：\n1 2 3 4 5 6 7 8 9 10 # 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break 函数式编程 高阶函数 map/reduce 利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # coding=utf-8 from functools import reduce def str2float(s): DIGITS = { \u0026#39;0\u0026#39;: 0, \u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2, \u0026#39;3\u0026#39;: 3, \u0026#39;4\u0026#39;: 4, \u0026#39;5\u0026#39;: 5, \u0026#39;6\u0026#39;: 6, \u0026#39;7\u0026#39;: 7, \u0026#39;8\u0026#39;: 8, \u0026#39;9\u0026#39;: 9 } def char2num(s): return DIGITS[s] s_int = s.split(\u0026#39;.\u0026#39;)[0] s_frac = s.split(\u0026#39;.\u0026#39;)[1] return reduce(lambda x, y: x * 10 + y, map(char2num, s_int)) + reduce( lambda x, y: x * 0.1 + y, map(char2num, s_frac[::-1])) / 10 print(\u0026#39;str2float(\\\u0026#39;123.456\\\u0026#39;) =\u0026#39;, str2float(\u0026#39;123.456\u0026#39;)) if abs(str2float(\u0026#39;123.456\u0026#39;) - 123.456) \u0026lt; 0.00001: print(\u0026#39;测试成功!\u0026#39;) else: print(\u0026#39;测试失败!\u0026#39;) filter filter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。\n返回函数 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。\n一个函数可以返回一个计算结果，也可以返回一个函数。\n返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。\n匿名函数 Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。\n装饰器 装饰器写的对入门者有难度，还未掌握，视频：https://www.bilibili.com/video/BV1Vv411x7hj?p=1\n在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。\ndecorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。\n偏函数 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。\n模块 自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。\n模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。\n创建自己的模块时，要注意：\n模块名要遵循Python变量命名规范，不要使用中文、特殊字符； 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。 使用模块 面向对象编程 类和实例 1 2 3 4 5 class Student(object): def __init__(self, name, score): self.name = name self.score = score 注意：特殊方法“init”前后分别有两个下划线！！！\n类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；\n方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；\n通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。\n和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; bart = Student(\u0026#39;Bart Simpson\u0026#39;, 59) \u0026gt;\u0026gt;\u0026gt; lisa = Student(\u0026#39;Lisa Simpson\u0026#39;, 87) \u0026gt;\u0026gt;\u0026gt; bart.age = 8 \u0026gt;\u0026gt;\u0026gt; bart.age 8 \u0026gt;\u0026gt;\u0026gt; lisa.age Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AttributeError: \u0026#39;Student\u0026#39; object has no attribute \u0026#39;age\u0026#39; 访问限制 在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。\n继承和多态 继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。\n动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。\n获取对象信息 通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：\n1 sum = obj.x + obj.y 就不要写：\n1 sum = getattr(obj, \u0026#39;x\u0026#39;) + getattr(obj, \u0026#39;y\u0026#39;) 一个正确的用法的例子如下：\n1 2 3 4 def readImage(fp): if hasattr(fp, \u0026#39;read\u0026#39;): return readData(fp) return None 假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。\n请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。\n实例属性和类属性 实例属性属于各个实例所有，互不干扰；\n类属性属于类所有，所有实例共享一个属性；\n不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。\n面向对象高级编程 使用__slots__ 1 2 class Student(object): __slots__ = (\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) # 用tuple定义允许绑定的属性名称 使用@property @property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。\n多重继承 由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。\n只允许单一继承的语言（如Java）不能使用MixIn的设计。\n定制类 Python的class允许定义许多定制方法，可以让我们非常方便地生成特定的类。\n本节介绍的是最常用的几个定制方法，还有很多可定制的方法，请参考Python的官方文档。\n使用枚举类 Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # coding=utf-8 # 把Student的gender属性改造为枚举类型，可以避免使用字符串： from enum import Enum, unique @unique class Gender(Enum): Male = 0 Female = 1 class Student(object): def __init__(self, name, gender): self.name = name self.gender = gender # 测试: bart = Student(\u0026#39;Bart\u0026#39;, Gender.Male) if bart.gender == Gender.Male: print(\u0026#39;测试通过!\u0026#39;) else: print(\u0026#39;测试失败!\u0026#39;) 使用元类 拿到api\n管理api\n渗透测试api\n","permalink":"https://www.ryujinx.top/posts/tech/python%E5%9F%BA%E7%A1%80/","summary":"python基础 数据类型和变量 Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数","title":""},{"content":"Shadowsocks-Rust 安装管理脚本 自用\n使用 1 wget -O ss-rust.sh --no-check-certificate https://raw.githubusercontent.com/xOS/Shadowsocks-Rust/master/ss-rust.sh \u0026amp;\u0026amp; chmod +x ss-rust.sh \u0026amp;\u0026amp; ./ss-rust.sh 修改 IPV6 优先 1 vi /etc/ss-rust/config.json 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;server\u0026#34;: \u0026#34;::\u0026#34;, \u0026#34;server_port\u0026#34;: 2525, \u0026#34;password\u0026#34;: \u0026#34;passwd\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;chacha20-ietf-poly1305\u0026#34;, \u0026#34;fast_open\u0026#34;: false, \u0026#34;mode\u0026#34;: \u0026#34;tcp_and_udp\u0026#34;, \u0026#34;user\u0026#34;:\u0026#34;nobody\u0026#34;, \u0026#34;timeout\u0026#34;:300, \u0026#34;nameserver\u0026#34;:\u0026#34;8.8.8.8\u0026#34;, \u0026#34;ipv6_first\u0026#34;: true } Snell 管理脚本 纯自用。\n使用 1 wget -O snell.sh --no-check-certificate https://git.io/Snell.sh \u0026amp;\u0026amp; chmod +x snell.sh \u0026amp;\u0026amp; ./snell.sh 注意 请手动放行防火墙相应端口。 由于源文件 tag 版本号过于混乱，目前更新只检测正式版 Snell，测试版请手动下载更新。 运行 VPS ToolBox 1 2 3 bash \u0026lt;(curl -Lso- https://sh.vps.dance/toolbox.sh) # 国内机如果不能用, 可尝试切换镜像 # bash \u0026lt;(curl -Lso- https://sh.vps.dance/toolbox.sh) fastgit 依赖 curl 命令 Ubuntu/Debian 执行 apt update -y \u0026amp;\u0026amp; apt install -y curl Centos/Redhat 执行 yum update -y \u0026amp;\u0026amp; yum install -y curl\n源码 https://github.com/VPSDance/scripts\n流媒体检测脚本： 1 bash \u0026lt;(curl -L -s check.unlock.media) Free DeepLX API 源码 https://github.com/OwO-Network/DeepLX\nRun on Linux Server 1 bash \u0026lt;(curl -Ls https://cpp.li/deeplx) Run on Mac Homebrew (Recommended) 1 2 3 4 5 6 7 8 9 10 11 brew tap owo-network/brew brew install deeplx brew services start owo-network/brew/deeplx # Update to the latest version brew update brew upgrade deeplx brew services restart owo-network/brew/deeplx # View the currently installed version brew list --versions deeplx After installation, start the daemon with the following command.\n1 2 systemctl daemon-reload systemctl enable deeplx Setup on Bob App Install bob-plugin-deeplx on Bob.\nSetup the API. Setup on immersive-translate Install Latest immersive-translate on your browser.\nClick on Developer Settings in the bottom left corner. Enable Beta experimental features.\nSet the URL.\nBackup the Docker Image of zu1k 1 docker run -itd -p 1188:80 missuo/deeplx-bk This docker image is not related to this project, as the original author deleted the image, it is only for backup.\nAuthor DeepL X © DeepL X Contributors, Released under the MIT License.\nDebian 10上安装最新版本Docker CE的步骤： 更新APT软件包缓存： 1 sudo apt-get update 安装所需的软件包以让APT可以通过HTTPS使用存储库： 1 sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common 添加Docker的官方GPG密钥： 1 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - 添加Docker的官方存储库： 1 sudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable\u0026#34; 再次更新APT软件包缓存： 1 sudo apt-get update 确保您要安装Docker的版本： 1 apt-cache policy docker-ce 安装Docker CE： 1 sudo apt-get install docker-ce docker-ce-cli containerd.io 验证Docker是否安装成功： 1 sudo docker run hello-world 如果一切正常，您应该能够看到\u0026quot;Hello from Docker\u0026quot;的输出。\n祝您安装成功！\nDebian 10上安装Docker Compose的步骤： 在GitHub的Docker Compose存储库上查找最新版本的Docker Compose： 1 sudo curl -L \u0026#34;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose 注：这个命令下载最新版本的Docker Compose的二进制文件到/usr/local/bin/docker-compose。\n将docker-compose文件设置为可执行： 1 sudo chmod +x /usr/local/bin/docker-compose 验证Docker Compose是否已成功安装： 1 docker-compose --version 如果一切正常，您应该看到Docker Compose的版本号。\n现在您已成功在Debian 10上安装并配置了Docker Compose。这将使您更轻松地管理和部署Docker容器。\n","permalink":"https://www.ryujinx.top/posts/tech/%E8%AE%B0%E5%BD%95vps%E7%9A%84%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4/","summary":"Shadowsocks-Rust 安装管理脚本 自用 使用 1 wget -O ss-rust.sh --no-check-certificate https://raw.githubusercontent.com/xOS/Shadowsocks-Rust/master/ss-rust.sh \u0026amp;\u0026amp; chmod +x ss-rust.sh \u0026amp;\u0026amp; ./ss-rust.sh 修改 IPV6 优先 1 vi /etc/ss-rust/config.json 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;server\u0026#34;: \u0026#34;::\u0026#34;, \u0026#34;server_port\u0026#34;: 2525, \u0026#34;password\u0026#34;: \u0026#34;passwd\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;chacha20-ietf-poly1305\u0026#34;, \u0026#34;fast_open\u0026#34;: false, \u0026#34;mode\u0026#34;: \u0026#34;tcp_and_udp\u0026#34;, \u0026#34;user\u0026#34;:\u0026#34;nobody\u0026#34;, \u0026#34;timeout\u0026#34;:300, \u0026#34;nameserver\u0026#34;:\u0026#34;8.8.8.8\u0026#34;, \u0026#34;ipv6_first\u0026#34;: true } Snell 管理脚本 纯自用","title":""},{"content":"","permalink":"https://www.ryujinx.top/about/","summary":"about","title":"🔍 关于"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 ","permalink":"https://www.ryujinx.top/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客","title":"🤝 友链"}]